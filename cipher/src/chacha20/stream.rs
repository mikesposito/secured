//! This module implements the ChaCha20 block cipher algorithm.
//! It provides the `ChaChaStream` struct for cipher operations,
//! supporting key and nonce initialization, block processing, and state management.

use std::sync::Arc;

use crate::{Bytes, Slice};

use rayon::prelude::*;

use super::core::{
  chacha20_rounds, safe_2words_counter_increment, seek_keystream, to_u32_slice, u32_to_u8_vec, xor,
  CONSTANTS, STATE_WORDS,
};

/// The number of blocks to process in each parallel encryption thread.
const PARALLEL_BLOCKS: usize = 32;

/// The number of words that each thread should process.
/// Each block is 64 bytes long, and each word is 4 bytes long.
/// Therefore, each thread manages up to 16.384 bytes of data.
/// TODO: This should be calculated dynamically based on the number of threads.
const WORDS_PER_THREAD: usize = PARALLEL_BLOCKS * STATE_WORDS;

/// A ChaCha20 cipher stream.
///
/// This struct represents a single state of the ChaCha20 cipher,
/// encapsulating a 512-bit state (16 words of 32 bits each) and a keystream of the same size.
pub struct ChaChaStream {
  pub state: [u32; 16],
  pub keystream: [u32; 16],
}

impl ChaChaStream {
  /// Constructs a new `ChaChaStream`.
  ///
  /// Initializes the ChaCha20 cipher state with the provided key and IV (initialization vector).
  /// The state is set up as per the ChaCha20 specification with constants, key, block counter set to zero, and nonce.
  ///
  /// # Arguments
  /// * `key` - A 256-bit key represented as 32 bytes.
  /// * `iv` - A 64-bit IV (nonce) represented as 8 bytes.
  ///
  /// # Returns
  /// A new `ChaChaStream` with the initialized state.
  pub fn new(key: [u8; 32], iv: [u8; 8]) -> Self {
    // Initialize an array of 16 unsigned 32-bit integers (u32) to represent the cipher's state.
    let mut state = [0u32; STATE_WORDS];

    // The first four words (16 bytes) of the state are set to the ChaCha20 constant.
    // This constant is the ASCII string "expand 32-byte k", used for creating the initial state.
    state[0..4].copy_from_slice(&CONSTANTS);

    // The next eight words (32 bytes) of the state are set to the encryption key.
    // The key is divided into 8 chunks, each containing 4 bytes (32 bits).
    // Each chunk is then converted from little-endian byte order to a u32 and stored in the state array.
    let key_chunks = key.chunks_exact(4);
    for (val, chunk) in state[4..12].iter_mut().zip(key_chunks) {
      *val = u32::from_le_bytes(chunk.try_into().unwrap());
    }

    // The block counter occupies the next two words (13th and 14th positions) in the state.
    // In ChaCha20, this counter is used to make each block unique.
    // We skip those they are set to zero already.
    // Here, we use the last 8-byte space of the block for the IV (initialization vector).
    let iv_chunks = iv.chunks_exact(4);
    for (val, chunk) in state[14..16].iter_mut().zip(iv_chunks) {
      *val = u32::from_le_bytes(chunk.try_into().unwrap());
    }

    // Finally, the constructed state array is cloned into the keystream.
    // The keystream will be used in the cipher operations and will be modified independently of the initial state.
    Self {
      state,
      keystream: state.clone(),
    }
  }

  /// Adds a block to the keystream.
  ///
  /// Updates the keystream by applying the ChaCha20 cipher rounds to the current state,
  /// then increments the block counter.
  pub fn add_block(&mut self) {
    self.keystream = self.state.clone();

    chacha20_rounds(&mut self.keystream, Some(self.state));

    safe_2words_counter_increment(&mut self.state[12..14]);
  }

  /// Processes the provided data using the ChaCha20 cipher.
  ///
  /// Encrypts or decrypts the input bytes by XORing them with the keystream generated by the cipher.
  /// This method is suitable for both encryption and decryption.
  /// Input Bytes: | Byte 0 | Byte 1 | Byte 2 | ... | Byte 63 |
  ///              |<----------- 64 bytes (512 bits) --------->|
  ///
  /// Step 1: Convert input bytes to 32-bit words
  /// 32-bit Words: | Word 0 | Word 1 | Word 2 | ... | Word 15 |
  ///                |<-------- 16 words (64 bytes) ----------->|
  ///
  /// Step 2: Process each 64-byte block
  /// For each block:
  ///   - Call `self.add_block()` to update the keystream for the current block.
  ///
  ///   - XOR each byte of the block with the corresponding byte in the keystream.
  ///     (The keystream is generated from the ChaCha20 state and is also 64 bytes long.)
  ///
  /// Processing:    | Word 0       | Word 1       | ... | Word 15       |
  /// Input Block:   | in[0..3]     | in[4..7]     | ... | in[60..63]    |
  /// Keystream:     | ks[0..3]     | ks[4..7]     | ... | ks[60..63]    |
  /// XOR Operation: | out[0..3]    | out[4..7]    | ... | out[60..63]   |
  ///                | (in XOR ks)  | (in XOR ks)  | ... | (in XOR ks)   |
  ///
  /// Step 3: Clear the keystream after processing all blocks
  ///               `self.clear_stream()`
  ///
  /// Step 4: Convert the processed 32-bit words back to bytes
  /// Output Bytes: | Byte 0 | Byte 1 | Byte 2 | ... | Byte 63 |
  ///
  /// # Arguments
  /// * `bytes_in` - A slice of bytes to be processed.
  ///
  /// # Returns
  /// A byte vector containing the processed data.
  pub fn process(&mut self, bytes_in: &Slice) -> Bytes {
    // Prepare the output vector of 32-bit words from the input
    let mut out: Vec<u32> = to_u32_slice(bytes_in);
    // Wrap the state in an Arc to allow for parallel processing
    let arc_state = Arc::new(self.state);

    // Process each chunk of 8 blocks in parallel
    out
      .par_chunks_mut(WORDS_PER_THREAD)
      .enumerate()
      .for_each(|(i, blocks_chunk)| {
        blocks_chunk
          .chunks_mut(STATE_WORDS)
          .enumerate()
          .for_each(|(j, block)| {
            // Cipher each 64-byte block in the chunk
            let chunk_keystream = seek_keystream(&arc_state, (i * PARALLEL_BLOCKS + j) as u64);
            xor(block, &chunk_keystream);
          });
      });

    // Clear the keystream
    self.clear_stream();

    // Convert the output to a byte vector
    let mut bytes_out = u32_to_u8_vec(&out);
    // Truncate the output to the length of the input,
    // as the output may contain extra bytes if the input length is not a multiple of 64
    bytes_out.truncate(bytes_in.len());
    bytes_out
  }

  fn clear_stream(&mut self) {
    // Clear the keystream
    self.keystream = [0u32; 16];
    // Reset the block counter
    self.state[12] = 0;
    self.state[13] = 0;
  }
}

#[cfg(test)]
mod tests {
  use super::*;

  const PLAINTEXT: &[u8; 100] = b"Nel mezzo del cammin di nostra vita mi ritrovai per una selva oscura che la diritta via era smarrita";
  const KEY: [u8; 32] = [
    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11, 0x12,
    0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
  ];
  const CIPHERTEXT: [u8; 100] = [
    146, 150, 64, 198, 111, 122, 166, 62, 64, 94, 27, 29, 148, 164, 141, 105, 199, 22, 190, 223,
    141, 210, 230, 218, 222, 247, 213, 231, 21, 24, 81, 93, 64, 103, 103, 96, 138, 0, 130, 225, 55,
    151, 65, 97, 250, 172, 209, 20, 9, 197, 0, 50, 177, 208, 241, 189, 105, 124, 63, 147, 39, 218,
    221, 241, 252, 156, 130, 147, 207, 121, 84, 225, 138, 201, 229, 31, 254, 87, 183, 196, 224,
    133, 32, 87, 225, 118, 59, 0, 115, 54, 126, 60, 122, 35, 3, 45, 150, 13, 11, 66,
  ];
  const IV: [u8; 8] = [0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8];

  #[test]
  fn it_constructs_an_unencrypted_chacha_block() {
    let chacha20 = ChaChaStream::new(KEY, IV);

    assert_eq!(chacha20.state.len(), 16);
    assert_eq!(chacha20.state[0..4], CONSTANTS);
    assert_eq!(
      chacha20.state[4..12],
      [67305985, 134678021, 202050057, 269422093, 336794129, 404166165, 471538201, 538910237]
    );
    assert_eq!(chacha20.state[12], 0);
    assert_eq!(chacha20.state[13], 0);
    assert_eq!(chacha20.state[14], 67305985);
    assert_eq!(chacha20.state[15], 134678021);
  }

  #[test]
  fn it_encrypts_data() {
    let mut chacha20 = ChaChaStream::new(KEY, IV);

    let encrypted_data = chacha20.process(PLAINTEXT);

    assert_eq!(encrypted_data, CIPHERTEXT);
  }

  #[test]
  fn it_can_reverse_encryption() {
    let mut chacha20 = ChaChaStream::new([1u8; 32], [2u8; 8]);
    let data = [0u8; 64];

    let encrypted_data = chacha20.process(&data);
    let decrypted_data = chacha20.process(&encrypted_data);

    assert_eq!(decrypted_data, data);
  }

  #[test]
  fn it_can_reverse_encryption_for_data_smaller_than_a_chunk() {
    let mut chacha20 = ChaChaStream::new([1u8; 32], [2u8; 8]);
    let data = [0u8; 1];

    let encrypted_data = chacha20.process(&data);
    let decrypted_data = chacha20.process(&encrypted_data);

    assert_eq!(decrypted_data, data);
  }
}
